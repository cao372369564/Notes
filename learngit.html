<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Document</title>
</head>
<body>
	
Git是在linux操作系统上，用C语言实现的‘分布式版本管理工具’，所以打开git bushHere之后，
所有的命令都是linux上的命令

========================================================
配置用户名 ：git config --global user.name "你的名字"
配置 email ：git comfig --global user.email "你的邮箱"
========================================================


第一步 ：创建本地版本库(Local)
	mkdir	创建文件夹
	cd	进入文件夹
	pwd	显示当前文件夹目录下的所有子文件
   
	  （确保目录名包括(包括父目录)不能含有中文  ）

第二步 ： 初始化版本库
	git init
		创建完成之后会有一个.git的目录，这个目录
	是默认隐藏的，用 ls -ah命令可以看见

第三步 ： 提交版本库
	git add 文件名
	git commit -m "这里写提交的备注"

	版本管理系统能跟踪文本改动，也会告诉你每次的改动，但是无法跟踪视频、音频图片这些二进制文件，只能告诉
	你图片从100KB改成120KB，具体改的啥，git并不清楚


========================================================
=======================版本回退=========================
    

    友情提示 ： git log中显示的一大串101523..的是commit id(版本号)
    
----(HEAD表示当前版本，上一个版本则可以写成HEAD^后面写版本号，上上个版本就是HEAD^^)----
----如果要把当前版本回退到上一个版本,可以使用 git reset命令 ：
	git reset --hard HEAD^
    然后查看内容， 输入命令 ：
	cat test.html
	如果要撤销这次回退，(在没有退出命令框的情况下,往上翻，找到之前的版本号),
	返回回退之前的版本git reset --hard 101523,
------------------------只用写几位就行了，git会自动寻找。

    再次查看 内容 输入命令 cat test.html


=====================================================
--------------------------------------------------

撤销工作区的修改 ： 
	git checkout -- 文件名

如果恰巧不小心写错，又添加到缓存区了，此时撤销缓存区的修改的命令是 ： 
	git reset HEAD 文件名
回退到上个版本 ：
	git reset --hard HEAD^
回退到更早的历史版本 ：
	git reset --hard 该版本的ID

--(git reset命令既可以回退版本，又可以把暂存区的修改退回到工作区，
	当我们用HEAD时，表示最新的版本),修改后再次查看 ：
	git status
 
	(假如不但添加到了缓存区，还提交到了本地仓库，那解决办法就是‘版本回退’到上一个版本,
	如果你不小心又提交到了远成仓库，那。。。你就真的惨了)



------------------------------------------------------
-----------------删除文件-----------------------------


	一般情况下，直接在文件管理器中删除文件，或者rm命令直接删除文件
	这个时候，git知道你删除了文件，工作区和版本库就不一致了，
	git status命令会告诉你那些文件被删除了。敲入命令 ：
		git rm license.html
	然后 ： 
		git commit -m "remove license.html"
 -----------假如你是误删，那没事，在rm之后，在commit提交前，版本库里面还有-------
	敲入命令 ： 
		git checkout -- license.html
	(这个 git checkout命令其实是用版本库的版本替换工作区的版本，
	无论工作区是修改还是删除，都可以'一键还原')


======================================================
====================分支管理命令======================

--------在原有的本地版本库中的文件中，修改文件内容
--------之后再操作Git创建分支
创建Git分支 ：
	git branch dev
切换到Git分支 ：
	git checkout dev
(或者创建切换写在一起 ：
	git checkout -b dev)
(查看Git分支 ： 
	git branch)
添加文件到缓存区 ：
	git add 文件名
提交到本地版本库 : 
	git commit -m "备注"
切换回master主线 ： 
	git checkout master
合并master主线和dev支线 ： 
	git merge dev
删除dev支线 ： 
	git branch -d dev
(再次查看分支 ：
	git branch)

==============================================
===========解决支线和主线都修改后的冲突=========

	在切换到支线更改内容，添加缓存并提交，切回主线之后，
	在主线并没有直接合并，而是又修改了一次，添加缓存并提交，
	这时提交git会提示有冲突，需要手动解决，解决之后才能合并，
	最后删除支线。来看命令操作！

	1.准备新的支线，并切换到支线 (这里分两步操作)
		创建名为dev支线	
				git branch dev
		切换到dev的支线
				git checkout dev
	2.在dev支线中，修改文件内容，添加到缓存区并提交版本库
		"这里是修改的内容"
		添加到缓存区
				git add 文件名
		提交到版本库
				git commit -m "备注信息"
	3.切换到master主线，同样修改内容并提交至版本库
		重复第2点的操作
	4.合并支线到主线，git报错，手动合并
		合并支线到主线
				git merge dev
		报错后手动合并
	5.再次提交，并删除支线
		再提交
				git add 文件名
				git commit -m "备注信息"
		删除支线
				git branch -d dev


==========================================================
==========================分支管理策略=====================
	
	在支线合并时，禁止Fast forward模式，依旧是创建并且换dev分支
		git branch dev
		git checkout dev
	修改文件内容,提交支线到版本库 ：
		git add 文件名
		git commit -m "备注"
	返回主线，合并分支内容到主线，禁用fast forward模式 ：
		git checkout master
		git merge --no-ff -m "备注" dev
	合并后，用git log查看分支历史 :
		git log --graph
=============================================================
=============================================================

----------------------Bug分支修改------------------------------
	当在支线敲代码的时候，发现主线上有bug，需要修复，而且很急的那种，
	但是你手头的支线代码还没敲完啊，但是还必须先改bug怎么办呢？

	git有个stash功能，它可以保存工作现场，也就是存档
		1.保存工作现场,返回主线 ：
			git stash
			git checkout master
		2.在主线创建并切换到支线，然后处理bug
			git checkout -b bug-dev
			纠正错误的代码
		3.切换回主线，合并，并删除bug-dev分支
			git checkout master
			git merge --no-ff -m "备注" bug-dev 
			git branch -d bug-dev
		4.回到工作现场，继续工作
			①git checkout dev
			②查看工作现场保存的地方 ：
				git stash list
			③用git stash apply或者git stash pop恢复
				git stash apply
				git stash drop
					(drop命令是删除已保存的工作现场,如果
					用了git stash pop则就包含和apply 和drop两步)
			④可以再次查看git stash list查看，再没有删除工作现场的情况下，
			可以多次用stash恢复指定版本，像这样
				git stash apply stash@[0]

==============================================================
=============================================================

---------------------Feature分支----------------------------
	在新功能添加完毕之后，返回主线，准备合并分支这千钧一发的时刻，
	你接收到了产品经理的需求，这个新功能舍弃不要了，想必心理一顿
	MMP，这个情况下如何操作呢？
		1.还是一样，创建并切换分支写功能 ：
			git checkout -b dev
			敲代码写功能
			git add 文件名
			git commit -m "备注"
		2.切换回主线，接到需求，不添加这个功能了，就地舍弃
			git checkout master
			git branch -d dev
				(git提示销毁失败)
		3.不能销毁，需要强行删除
			git branch -D dev

=================================================================
===================多人协作开发==================================
	推送本地master到github ：
		git push origin master
	推送本地其他分支，比如dev，就改成 ：
		git push origin dev

====通常多人开发，大家都会克隆一份往master和dev分支上推送各自的修改
		git clone git@github.com:账户名/仓库名.git
	克隆下来的内容只能看到master主线，看不到其他分支，可以查看一下 ：
		git branch
	如果小伙伴要在本地的dev分支开发，就必须要创建远程origin的dev分支 ：
		git checkout -b dev origin/dev
	然后，他就会在本地dev上继续修改，并不定时push一下本地dev分支到远程：
		git add 文件名
		git commit -m "备注"
		git push origin dev
====恰巧，你也对这个文件做了修改，并试图推送
		git add 文件名
		git commit -m "备注"
		git push origin dev
====这个时候就会显示推送失败，因为小伙伴的推送和你的推送冲突了，这个时候，
====就需要把他的提交从origin/dev抓取下来，在本地合并，再推送:
		git pull 
====git pull 也失败了，因为没指定本地dev分支与远程origin/dev分支的链接，
====根据提示，设置dev和origin/dev的链接
		git branch --set-upstream-to=origin/dev dev
	再次拉取 :
		git pull 
====提示成功，但合并还有冲突，解决办法和分支管理中解决冲突一样，解决完,
====提交并push ：
		git commit -m "备注"
		git push origin dev


==============================================================

	<!--=======================================================

	=======================与查询有关的====================
	查询仓库状态 ：
		git status
	比较文件差异(请在git add之前使用) ：
		git diff test.html
	------(diff 意为 difference,查看工作区和版本库之间的区别)
	查看仓库历史记录(详细) ：
		git log
	查看仓库历史记录(单行) : 
		git log --pretty==oneline或git log --oneline
	查看所有版本的commit ID ：
		git reflog
	查看历史修改的图表 ：
		git --graph
	只查看历史提交的备注时间线 ：
		git --graph --pretty=oneline --abbrev-commit
	查看修改日志 ：
		(git log命令中显示从最近到最远的提交日志，一共会显示3次提交，
		最近的一次叫append GPL，上一次叫add distributed，
		最早的一次是wrote a readme file)

	=======================================================
	=======================================================

	查看完命令之后，就可以放心提交仓库了
	第一步 ：
		git add test.html
		(第二步执行前，可以在运行git status 看看状态)
	第二步 ： 
		git commit -m ""
		(提交之后再次查看状态 git status) 
		
		
		====================================================
	------------网上总结的---Git分支管理命令-------------

	创建分支 :
		git branch dev
	切换分支 ： 
		git checkout dev
	创建分支并切换分支 ：
		git checkout -b dev
	删除分支 ： 
		git branch -d dev
	再分支上提交新的版本 ：
		git commit -a -m "dev1"
	合并分支 ： 
		git merge dev
	分支的合并后显示log ：
		git log --oneline -graph -decorate


	在分支开发的过程中遇到其他问题需要切换其他分支 -----
	----保留写好的内容，再切换到主干，保留内容 ：
		git stash
	再次切换分支后需要应用一下保留的内容 ：
		git stash apply
	丢掉保存的内容 :
		git stash drop
	使用并丢掉 : 
		git stash pop
	最佳分支 -----
	---有的时候开发需要合并指定的内容,而不是合并所有的提交,所以需要挑选最好的，
	自己生产版本合并分支把树杈掰到主干上 : 
		git rebase

	======================================================
	---------------------添加到远程仓库-------------------
		push -u 
			(-u参数upstream)原意是向上流动
	链接远程仓库 ：
		git remote add origin (仓库的地址)
	查看远程仓库 ：
		git remote -v
	删除远程仓库 ：
		git remote rm origin

	==================与GitHub有关的=======================

	本地仓库关联GitHub ：
		git remote add origin 网站上的仓库地址
	第一次推送本地仓库至GitHub ： 
		git push -u origin master
	从GitHub上克隆到本地库 :
		git clone 网站上的仓库地址
	从本地master主线推送至github 
		git push origin master
	如果推送支线dev到github
		git push origin dev
	但是并不一定要把本地分支推送远程，只需要推送
		master 分支是主分支，要时刻与远程同步
		dev分支是开发分支，团队成员都在上面工作，所以也需要远程同步
		bug分支只需要修复本地bug，不需要推到远程
		分支完全可以在本地藏着玩，推不推送，看自己心情 -->
	<!-- ========================================================== -->
 
	<!-- git pull和git fetch区别 
			
		git local里面又包含local和remote两个仓库git pull比较暴力，
	直接可以把远程仓库的代码更新至本地仓库里面的local和remote，看不到细节 
		git fetch 则是把远程仓库的代码更新至本地仓库中的remote，对local并
	不做影响，所以需要再 git merge 再次更新本地仓库中的local
		注意 ：不要用git pull，改用git fetch和git merge
	-->

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Vue cli各个文件功能介绍</title>
</head>
<body>
=========================================================
前言 ：vue中的import、export和export default的注意问题
    import
        1.引入一个依赖包的时候，是不需要相对路径的
        2.引入一个自己写的js文件，则需要相对路径。
        3.什么情况下import需要用{}引入,什么情况下只用一个变量？
            (1). 用export抛出的变量需要用{}
            (2). 用export default跑出的变量，只需要自己起一个名字
            就可以了 ：
                例: a.js文件中
                        var obj = {name : '渣渣辉'};
                        export default obj;
                    b.js文件中
                        import aaa from './a.js'
                        console.log(aaa.name)
    export default和export
        1.一个js文件中只能有一个export default
        2.一个js文件可以有很多歌 export
        3.导出export或export default的js文件自己也可以使用

================================================================
*****************************************************************

node_modules        -------------安装所依赖的各个插件包
public              -------------主入口文件，呈现给用户看的
src                 -------------开发人员要编辑写的代码
.gitignore          -------------想让git仓库忽视的文件，写进来，
                        可以不用上传
babel.config.js     -------------配置babel的，决定es6如何编译，给哪个
                        浏览器用的设置
package.lock.json   -------------安装时候，所需要各个插件的当前版本，
                        不会随着插件升级版本而改变之前安装时候的版本。
package.json        -------------安装所需要的各个插件的链接地址
readme.md           -------------这里面是vue在cmd中的命令           

&&&&&&&&    打开src
assets                       放置的图片
components                   组件
App.vue                      根组件
main.js                      主入口配置文件,作用于主入口文件

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
^^^^^^^^^^^^^^^^^^vue router 安装与使用^^^^^^^^^^^^^^^^^^^^^^^^^^
安装router！命令行 ：
        vue add router
--------提示 是否需要“对路由器使用历史记录模式”，第一次选 “no”
完成之后，vue create的文件夹会多出来2个文件
        view        ----------里面放的是点击页面链接后切换到另一个地方的一个组件
        router.js   ----------配置好的路由，路径。
之后在命令行启动服务器 : 
        npm run serve
在浏览器中打开 ： 
        localhost:8080

=================下面是主入口文件内容的书写==========================
                    ----main.js----
node_modules当中会有一个叫vue-router的文件夹，里面的文件写了一个构造函数，
如果要使用，则可以用 import Router from "vue-router",Router就是构造函数
----然后 Vue.use(Router)就相当于使用了它。
----接下来就是就是实例化这个router了 ：
        const myRouter = new Router({
<!-- 这个routes是一个路径，value值是一个数组形式，每一位都是一个对象形式 -->
            routes : [
                {
<!-- path定义一个路径，里面的‘/’，表示的就是'localhost:8080/#/'后面的内容 -->
<!-- path的value值,在App.vue中的router-link标签中没有配置，如果写path:'/aaa'，
这个网页将不会显示内容,只能手动在网址后面添加'aaa'字样才能显示 -->
                    path : '/',
<!-- component是一个组件,所以是单数,没有‘s’, 它的值写import后面的那个名字，
    value值是一个变量,不是字符串,它显示导进来的组件名字-->
                    component : Home
                }
            ]
        })
----配置完这个路由，就可以把这个路由放进Vue实例化对象里面了，
        new Vue({
    <!-- 这里router属性的书写，和局部组件书写没什么区别 -->
            router : myRouter,
            render : h => h(App)
        }).mount('#app')

----配置完，所有东西都会再次显示出来了，但是网址当中莫名有一个'#',很不爽，怎么去掉呢？
----还记得安装vue router的时候，提示说'是否使用历史记录模式'那句话吗,现在用上了
        在之前写的实例化router对象里面，添加一个属性 mode : 'history' ,
    保存刷新以后，从新输入网址localhost:8080,发现没有让人不爽的#了

***********在根组件App.vue当中自己写页面内容
书接上文，要把根组件中，也就是vue接管的#app标签中的内容都注释掉，自己写两个跳转标签，
也就是这样 :
        <a href="/">Home</a>
        <a href="/about">About</a>
    这样自己写跳转页面，在协议域名端口都相同的情况下，测试了一下，发现有问题，
页面的网址后面虽然跳转了，但是页面似乎没动静啊！怎么样让它既网址跳转，页面内容也切换，
怎么办呢？  别着急，不用自己写，vue-cli设计了一个标签叫 ： 
        <router-view></router-view>
    翻译过来叫‘路由视图’，它对应的就是路由配置component的显示区，可以完美的切换
    出来a标签的功能 ： 
            <a href="/">Home</a>
            <a href="/about">About</a>
    <!-- 这个router-view标签虽然好，但是也别把a标签包裹起来，
    可能是因为不兼容吧，包裹进去之后，什么也不显示，有兴趣你可以研究一下-->
            <router-view></router-view>
    尝试一下，成功了！但是，你再多点几下这标签，又有新问题了，一直点击同一个a标签，
就会一直跳转，耗费了很多网络性能，怎么办呢?vue-cli又提供了另一个标签：
            <router-link></router-link>
    这个标签，可以做到a标签做不到的事情，重复点同一个标签，不会进行多次网络请求,
岂不是更省事，把上面的a标签注释掉，然后这样写 ：
            <router-link>Home</router-link>
            <router-link>About</router-link>
    <!-- 同样，router-link在router-view标签里面不显示，一定不要写错了 -->
            <router-view></router-view>
    保存之后，发现跳转标签，并没有显示出来，为什么?当然是因为没写跳转到哪里阿，
于是，再加上一个router-link本身的属性 to，它和a标签中的href有一样的功能 ：
            <router-link to="/">Home</router-link>
            <router-link to="/about">About</router-link>
            <router-view></router-view>
    到此，一个基本的页面就已经布置完了，但是我想让标签内容跟我的数据绑定在一块，
动态显示不同的数据！
    在 template标签下面，写一个script标签 ：
            <script>
                export default {
                //和实例化vue中的局部组件写法一样
                    data(){
                        return {
                    // 绑定上面router-link中的属性'to'
                            homeLink : '/',
                            aboutLink : '/about'
                        }
                    }
                }
            </script>
    在接下来，绑定属性"to",便可以用data里面的变量 ： 
            <router-link :to="homeLink">Home</router-link>
            <router-link :to="aboutLink">About</router-link>
            <router-view></router-view>
    保存刷新，效果一样！现在不想在我自己的代码中写script标签，我觉得有点乱，
在别的文件中写行不行？
    行！回到最main.js文件当中的路由配置，Router下的routes，在这个数组当中，
vue还提供了一个可配置的name属性，name就是路由的名字，value必须是字符串,这样
通过这个名字找到router.js中routes配置下path的路径，然后跳转 ： 
    <!-- name属性，可以让router-link标签直接跳转到routes配置好的path下 -->
            <router-link :to="{name : 'home'}"></router-link>
<!-- 书写路由配置的名字的时候，绑定的必须是一个对象形式 -->
<!-- 如果对象里面的value值不写成字符串格式，而是变量，vue就会找data里面的数据 -->
            <router-link :to="{name : 'about'}"></router-link>
            <router-view></router-view>

*****************************************************************
***************************路由和嵌套路由*************************

在vue create的文件中编辑，
    1. 先在views视口中添加需要的路由，用.vue结尾
    2. 在router.js中，用import导入views中需要的文件，并在routes中
    配置path网址路径(value值是字符串)，另起的name名字(value值是字符串)，
    导入的component名字(value值是变量)
    3. 打开根组件App.vue,用router-link标签写路由组件，并添加属性'to'
    4. 调整布局，导航里面的路由一般都用ul，li写，怎么让router-link变成
    li呢，这里使用了自定义标签：
            <ul>
                <router-link tag='li'></router-link>
            </ul>
    这里的tag属性，就是vue可以让router-link编译成你想要的标签,这里需要li
    5. 在根组件中简单布局，书写样式,并在main.js中用import引入


==================================================================        
    
··························嵌套路由后半段····························
    在views中，每一个组件都是第一层路由，但一层路由往往不够，还需要嵌套
嵌套路由如果也写在views难免有些混乱，找不到哪里是哪里，所以二层嵌套路由
选择在src文件夹下的components文件夹里面创建一个文件夹用来放置第一层路由
的嵌套路由
    写嵌套路由的名字，首位字母也要大写，创建完成之后，同样，也是在router.js
中用import引入文件,并配置它的子路由：
            routes : [
                {
                    path : '/commity',
                    name : 'commity',
                    component : Commity,
        <!-- 这个children就是要放置嵌套路由的配置，和routes一样 -->
                    children : [
                        {}
                    ]
                }
            ]
    这样也就配置好了第一层路由的嵌套路由了,下面就到写嵌套路由的内容了，在哪写？
当然是在views中的commity中写了，路由书写顺序：
            1.书写引入路由文件
            2.router.js引入并配置
            3.在父级路由中写标签router-link和router-view,并绑定属性to
            4.保存测试嵌套路由是否显示
    结束之后，我又想在顶部nav中加一个class，让选中的li上加一个下划线，怎么办？
打开F12，选中一个第一层路由的任意一个，会发现，vue会自动加一个class，名字是
router-link-active和router-link-exact-active，我们先讨论前一个class，只要在
前一个类名上添加就样式就比自己写省事多了
            .router-link-active{
                你要设置的样式1
                你要设置的样式2
                ...
            }
    但是发现有问题啊，为啥li中‘首页’它的样式会一直存在,没有跟随点击切换类名？
别着急，我来告诉你，因为router-link标签的to属性，是一个字符串，vue会给这个to
属性加class，‘首页’这个path字符串是'/'，而别的比如是community则是'/commiunity',
他是包含了一个‘/’,所以这个class在给community添加类名的时候，同时也给‘首页’添加
了class类名，解决办法就是：
    把router-link标签中to属性改成/home，router.js中path='/'也改成/home，就不
存在包含和被包含了。
    <!-- 如果点击嵌套路由也想让父级路由的class存在，让path路径跟着父级路由下来 -->
    <!-- router-link-exact-active是精确匹配原则，也就是只有被点击的router被匹配到 -->
    router-link-active默认全包含匹配原则，意思是path名全包含在当前router path名，
开头的router也会被匹配到。
            1.<router-link to='/'>
            2.<router-link to='/a'>
            3.<router-link to='/b'>
            4.<router-link to='/ab'>
    2或3被选中，1号也会被匹配到router-link-active,4号被选中1号2号也会被匹配到
router-link-active。可以通过router添加exact属性改变为精确匹配。

    如果嫌这两个类名比较长，不好记，想简短一点，也可以！首先回到router.js中，在
实例化new Router({}),重新配置它的类名：
                linkActiveClass : 'active'
                linkExactActiveClass : 'exact'
    完成之后，样式里面的类名也需要改一下!
<!-- 在写各个路由组件的时候，style样式会相互影响，如果不想他们的样式互相影响，可以这样 -->
                <style scoped>
                </style>
<!-- 加上 scoped之后，这个路由的样式将不会影响其他路由 -->

===============================================================================
================================动态路由========================================

    router.js中，配置路由routes中path的路径不固定，就是不固定的路由，形式这样写：
                path: '/question/:id'
    这个 :id, vue就会认为它是一个动态路由。
    重新写一个嵌套组件在components中,并在router.js引入和配置
                import Question from './components/Question.vue'
                routes : [{
    <!-- 这个配置放在跟一级路由配置的尾部 -->
                    path: '/question/:id',
                    name: 'question',
                    component: Question
                }]
    在Academic.vue中，把li改成router-link，并绑定to属性，value值写成一个对象
{name:'question'}，这个对象中的name的value值引入router.js中路由配置下name值为
question对应的path值。
    如果要传path路径中question/:id这个绑定的动态id，可以在:to的属性值里面再添加
    <!-- {name:'question',params:{item.questionId}} -->
一个属性params,这个属性是一个对象，对象里面写的是path路径中绑定的动态id

===||实现点击 ‘学术讨论’下面的li中的某一项，让问题的 后面也显示出来这个 li里面的内容||

————————这里要补充一个生命周期函数 
    created声明周期函数，这个函数里面,this、data、methods这些数据都初始化完毕了，
在这个生命周期函数中,this是一个对象，包含了很多个方法，当然也包括router路由，
这里面有两个关于路由的，($route和$router),$router是VueRouter的实例，相当于一个
全局的路由器对象；$route则是当前正在跳转的路由对象，可以从中获取name.path,params,
query等，所以这里为了传参，用的肯定是$route
    既然找到了$route, 那就要使用它，这里用到的是这个id值，所以先取出来
                const questionId = this.$route.params.id;
    还会用到与其相关的index索引值，这里用到一个es6的方法 : 
                const index = this.questionList.findIndex( item => this.questionId == questionId )
    <!-- 这里的[]就是data数据中的数组，这里执行的结果如果有的话返回对应索引值，没有返回-1 -->

    在data中设置一个question，value值为空字符串 ：
                this.question = this.questionList[index].title
    这样，很巧妙的就取到data里面这个数组中的任何属性和值
    最后，在template下的div下的 问题 后加上 {{ question }}，大功告成

====||实现点击社区，就能直接默认显示一个子路由的内容||
    提示 ： 利用服务器重定向
        回到router.js中，vue还提供一个属性，就是为了解决这个问题的
        在要设置默认显示的路由下面，添加redirect属性，value值为要显示的path路径
        
====||如果用户在网址输入不存在的id号，该怎么办？||
    提示 ： 输入不存在的id，让其跳转到报错页面
    首先要写一个容错处理，这个id号不存在，findIndex值就是-1，还要在components写
一个组件，让用户输入不存在的id号跳转到这个页面
                if(index == -1){
    <!-- 这个实例化对象中有replace方法，可以替换页面跳转指定页面 -->
    <!-- 里面既可以直接传path路径，又可以写成对象形式{name:'err'} -->
                    this.$router.replace('')
                }else{
                    this.requestion = this.requestionList[index].title
                }
    除了用this.$router.replace('')可以替换网页，this.$router.push('')同样可以，
他们在不同的场景选择用哪个方法，具体比较请百度。

====||实现输入网址，直接默认跳转/home路由里面，怎么办？||
    提示：仿照之前服务器重定向
    在router.js中重新写一个一层路由，
                {
        <!-- 这里"*"的意思就是，只要在router.js中没有配置的路径，都会被匹配到，
        不处理配置过的path路径值 -->
                    path: '*',
                    redirect: '/home'
                }
    这样就很简单的实现了，但新问题又出现了，因为path匹配的是'/'，所以无论是输入错网址，
还是故意输入错误，它都会直接跳转到这个home页面上，假如我有一个/home1页面，但是不小心
输入成/home2，给用户造成假象，页面怎么跳转不了，而用户也意识不到自己输入错误,怎么办？
    还是刚刚写的属性redirect,它不仅可以写成一个字符串，还可以写成一个方法，可以接收一个
参数 ：
                redirect(to){ console.log(to) }
    这个形参to是一个对象，对象里面有一个path属性，根据这个path属性就可以判断重定向到哪里了
                redirect(to){
                    if(to.path == '/'){
                <!-- 这里一定要注意 return给这个direct，写其他的不一定生效 -->
                        return '/home'
                    }else{
                <!-- 这里的路径可以写成对象形式，外面不加字符串 -->
                        return {name : 'err'}
                    }
                }            
    
===============================================================================
===========================router-view的复用====================================
    这个知识点更简单，要实现在首页里面，不仅只有"首页"两个字，还想展示commity下的
academic这个路由的内容怎么办?
    回到router.js中，配置一下routes下找到path值为/home的对象，操作component，这个
component是个单数，表示一个，如果想表示多个就把它写成"components",此时它可以接收一个对象，
这个对象里面有 default属性，value值是默认让它显示的值，如果还想让它显示其他的路由组件,
就给他加一个属性，这个属性key值就是要显示的路由组件里面配置的name值，字符串形式，value值
则是要显示路由组件里面配置的component的value值！一定要注意这点！
                components:{
                    default: Home,
                    'academic': Academic
                }
    还差一步，回到App.vue根组件，多写一个router-view标签，并添加一个name属性，value值为
刚刚设置好的key值
                <router-view name='academic'/>
    保存，重新进入网页就完成了

===============================================================================
在router.js当中的routes配置下，路由会一层一层的嵌套下去，嵌套的越多，path下的value值
写的就会越多，比如这样
                path : '/commity/academic/question/dev/container'
    这样就会写很多前面的分支，如果这个分支下面还有分支，则会写很多惹人烦的路径，这个时候，
可以简单点写,还是上面这个路径：
    <!-- 注意：这里面的value值，一定不能加"/"，因为这个"/"会匹配到根目录 -->
                path : 'container'
    <!-- redirect里面的路径不能省略 -->
    这样，router路由就可以匹配到它的第n层嵌套路由了
    
=================================导航守卫=======================================
    切换路由的时候，会有一个弹框提示，符合要求才能进，不符合要求不能进，这就是导航守卫

一、全局守卫

    这个守卫是Router实例的一个属性beforeEach()，所以在router.js中，如果使用这个属性，需要
先拿到这个实例对象
                const router = new Router({})
                router.beforeEach( (to,from,next) =>{
                    <!-- to 要去到哪里 -->
                    <!-- from 从哪来 -->
                    <!-- to和from都是一个对象  -->
                    <!-- next() 是否允许通过,next()允许跳转，next(false)禁止跳转 -->
                    <!-- next()里面填的是path路径，或者直接写一个对象形式，key值
                    是name，而value值是被命名的路径名字 -->
                } )

                <!-- 这样默认导出router这个变量也是一样的 -->
                export default router
    
    to对象中有一个path路径，利用这个path来写判断条件
        <!-- 补充原生js方法comfirm的用法 -->
        <!-- confirm是一个方法，可以传一个参数必须是String类型，像这样confirm('111') -->
        <!-- 浏览器会弹出一个对话框，含有一个"确定"和"取消"按键,点击之后返回一个Boolean值 -->
        <!-- "确定"返回true,"取消"则返回false -->
        confirm在被赋予变量的时候，也会执行
                router.beforeEach( (to,from,next) => {
                   if(to.path == '/commity/academic'){
                       const answer = confirm("你还没有登录，要登录吗？")
                       if(answer){
                           next( {name : 'personal'} )
                       }else{
                           next(false)
                       }
                   } else{
                       next()
                   }
                } )
====这是全局守卫，这样做难免有点傻，因为这样做就相当于问了所有人，是不是要进“学术讨论”，有的
用户指向看看首页，课程什么的，并不想去社区，还问别人就有点傻，所以就需要局部守卫，这个局部守卫
放在社区门口，再次把关，这时候就问他"你有票吗",有了进去，没有不让进，其实并不叫局部守卫，它叫
路由独享守卫，局部守卫是为了更好的理解。

二、路由独享守卫

    路由独享守卫的方法名 ： beforeEnter(),稍稍有点不同的是，这个函数里面的参数不再是一个方法，
而直接是形参beforeEnter(to,from,next){}
    直接在router.js中的嵌套组件'academic'路由对象中，添加这个判断方法
                beforeEnter(to,from,next){
                    const answer = confirm('你还没有登录，要登录吗?')
                    if(answer){
                        next( {name : 'personal'} )
                    }else{
                        next(false)
                    }
                }
    但是，如果这个路由内容没有被别的路由引用这样就够了，一旦引用了它显得就很没有意义，意思就是，
有两个房间在开展学术讨论，只在一个房间放守卫审核条件，另一个房间却不管，这个路由独享守卫就没有什么
意义了。最后就引出了第三种守卫的方法 ： 组件内守卫

三、组件内守卫
    这个守卫的作用是，只要引用了这个组件的内容，守卫就能起作用，开启审核条件。
    打开学术研讨路由文件Academic.vue,在默认导出里面添加守卫方法:beforeRouteEnter(to,from,next),
同样，这个方法一样里面的参数仍然是to,from,next
            <!-- 注意：beforeRouteEnter里面的Route不是Router -->
                beforeRouteEnter(to,from,next){
                    const answer = confirm('你还没有登录，要登录吗？')
                    if(answer){
                        next( {name : 'personal'} )
                    }else{
                        next(false)
                    }
                }
    登录提示都写了，不写登录信息也不行啊，进不去页面！剩下的就是写登录信息了，接下来的内容
叫做路由源信息
===============================================================================
===============================路由源信息=======================================
    其实没有这么高大上，很挫的
    路由源信息就写在router.js中commity的里面，
                <!-- meta是一个对象 -->
                meta: {
                <!-- 在这个对象里面任意定义属性，这里定义了login登录信息 -->
                    login : false
                }
    这个meta对象的属性既可以在/commity的路径下取到，又能在它的子路由下取到,在子路由
Personal.vue里面，创建 created生命周期函数，打印this，就可以在this对象里面的$route对象
中的match数组第[0]位中有名为meta的对象，这里面放的就是父路由设置的login信息.
                created(){
                    const loginFlag = this.$route.matched[0].meta.login
                }
    接下来的事就简单了，写一个登录按钮，让这个login信息每次取反，作为登录信息
    <!-- button按钮上的信息也可以用login控制，为true的时候显示退出，false显示登录 -->
                <button @click='handleClick'>{{ loginFlag ? "退出" : "登录" }} </button>
    <!-- 一定不要在created生命周期函数中定义变量,因为methods,访问不到 -->
                data (){
                    return {
                        loginFlag : false
                    }
                }
                methods : {
                    handleClick(){
                        每次点击loginFlag值取反，然后再赋值
                        给this.$route.matched[0].meta.login
                    }
                }
    现在personal.vue中已经实现了登录，接下来要实现acadedmic中login信息的录入，切换到
Academic.vue中 ： 
    <!-- 这个组件里面，因为守卫还没有允许通过,在beforeRouterEnter函数结束前，就还没有进入
        这个组件，实例也就还没有创建,所以this的值这里是undefined -->
                const isLogin = this.$route.matched[0].meta.login
    <!-- 不能用this,但是这个beforeRouteEnter里面的to形参,里面可以找到meta对象和属性login -->
                const isLogin = to.matched[0].meta.login
    判断，如果是true的话,不用再继续走判断登录信息了,直接返回
                if(isLogin){
                    <!-- 直接跳转，然后返回,不往下执行了 -->
                    next()
                    return
                }
    注意 ：meta这个可以自定义属性的对象,只能子路由传给父路由,不能兄弟路由传递,有局限性
    这里注释掉首页的router-view标签，不用它,并在router.js中注释掉components中的
academic属性,只让路由拦截社区就可以了
    
    ||实现离开academic页面,显示提示信息,确认后离开,取消留在此页面||

        同样也是用组件内守卫实现,vue提供一个beforeRouteLeave,用来确认是否离开当前
    此页面
            <!-- 同样接收这三个参数 -->
                beforeRouteLeave(to,from,next){
                    const answer = confirm('确定要离开吗？')
                    if(answer){
                        next()
                    }else{
                        next(false)
                    }
                }
    
=========================================================================================
========================================路由懒加载========================================
    输入网址后，只显示首屏内容，点击其他路由的时候，再去加载其他路由的信息，这样做可以优化用户体验
    回到router.js中，将import引入的相对路径都注释掉
    改用懒加载的方式：
                <!-- 换成Es5的模式  -->
                <!-- var Home = function (){
                    return import('./views/Home')
                } -->
                const Home = () => import('./views/Home')



==========================================================================================
=======================================事件总线============================================
    vue的prototype上添加了一个属性,这个属性是一个另外的一个vue实例,常命名为
bus,当它触发一个方法时,也就可以监听自己的方法.
    事件总线可以跨越父级,直接可以兄弟之间传递,不用再次经过父级中转.

    在main.js中,给构造函数Vue的原型上添加一个bus属性,值仍然是一个Vue实例
                Vue.prototype.bus = new Vue();
    回到组件AddStudent.vue组件中,就可以把methods中的自定义事件改一下
                this.$emit('add',this.name) => this.bus.$emit('add',this.name)
    此时,它的兄弟组件就可以直接监听到自定义事件传来的事件了,切换到studentList.vue
                data (){
                    return {
                        studentList : []
                    }
                },
                created (){
                    this.bus.$on('add' name => {
                        <!-- name是兄弟组件传过来的 -->
                        this.studentList.push(name)
                    })
                }


==========================================================================================
============================================VUEX==========================================
    vuex是一个共享仓库,可以以一传多












</body>
</html>